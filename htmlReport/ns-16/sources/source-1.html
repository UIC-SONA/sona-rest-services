


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ChatService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ec.gob.conagopare.sona.modules.chat.services</a>
</div>

<h1>Coverage Summary for Class: ChatService (ec.gob.conagopare.sona.modules.chat.services)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ChatService</td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (20/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65,4%
  </span>
  <span class="absValue">
    (17/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93,6%
  </span>
  <span class="absValue">
    (117/125)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ChatService$$SpringCGLIB$$0</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (20/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65,4%
  </span>
  <span class="absValue">
    (17/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93,6%
  </span>
  <span class="absValue">
    (117/125)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ec.gob.conagopare.sona.modules.chat.services;
&nbsp;
&nbsp;import ec.gob.conagopare.sona.application.common.utils.FileUtils;
&nbsp;import ec.gob.conagopare.sona.modules.chat.dto.ChatMessagePayload;
&nbsp;import ec.gob.conagopare.sona.modules.chat.dto.ReadMessages;
&nbsp;import ec.gob.conagopare.sona.modules.chat.models.*;
&nbsp;import ec.gob.conagopare.sona.modules.chat.repositories.ChatRoomRepository;
&nbsp;import ec.gob.conagopare.sona.modules.user.service.NotificationService;
&nbsp;import ec.gob.conagopare.sona.modules.user.service.UserService;
&nbsp;import io.github.luidmidev.jakarta.validations.ContentType;
&nbsp;import io.github.luidmidev.jakarta.validations.FileSize;
&nbsp;import io.github.luidmidev.jakarta.validations.Image;
&nbsp;import io.github.luidmidev.springframework.web.problemdetails.ProblemDetails;
&nbsp;import io.github.luidmidev.storage.Storage;
&nbsp;import io.github.luidmidev.storage.Stored;
&nbsp;import jakarta.validation.constraints.NotEmpty;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.bson.Document;
&nbsp;import org.bson.types.ObjectId;
&nbsp;import org.springframework.data.domain.Sort;
&nbsp;import org.springframework.data.mongodb.core.MongoTemplate;
&nbsp;import org.springframework.data.mongodb.core.aggregation.Aggregation;
&nbsp;import org.springframework.data.mongodb.core.aggregation.ArrayOperators;
&nbsp;import org.springframework.data.mongodb.core.query.Criteria;
&nbsp;import org.springframework.data.mongodb.core.query.Query;
&nbsp;import org.springframework.data.mongodb.core.query.Update;
&nbsp;import org.springframework.messaging.simp.SimpMessagingTemplate;
&nbsp;import org.springframework.security.access.prepost.PreAuthorize;
&nbsp;import org.springframework.security.oauth2.jwt.Jwt;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.transaction.annotation.Transactional;
&nbsp;import org.springframework.validation.annotation.Validated;
&nbsp;import org.springframework.web.multipart.MultipartFile;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.*;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;import static java.util.concurrent.CompletableFuture.runAsync;
&nbsp;
<b class="fc">&nbsp;@Slf4j</b>
&nbsp;@Service
&nbsp;@Validated
&nbsp;@Transactional
&nbsp;@RequiredArgsConstructor
&nbsp;public class ChatService {
&nbsp;
&nbsp;    private static final String CHAT_CHUNK_NUMBER_KEY = &quot;number&quot;;
&nbsp;    private static final String CHAT_CHUNK_ROOM_KEY = &quot;room.$id&quot;;
&nbsp;    private static final String USERS_CHATS_PATH = &quot;users/%d/chats/%s/%s&quot;;
&nbsp;    private static final String MESSAGES = &quot;messages&quot;;
&nbsp;
&nbsp;    private final SimpMessagingTemplate messaging;
&nbsp;    private final MongoTemplate mongoTemplate;
&nbsp;    private final UserService userService;
&nbsp;    private final ChatRoomRepository roomRepository;
&nbsp;    private final NotificationService notificationService;
&nbsp;    private final Storage storage;
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public ChatMessagePayload sendMessage(@NotEmpty String message, String roomId, String requestId, Jwt jwt) {
<b class="fc">&nbsp;        var user = userService.getUser(jwt);</b>
<b class="fc">&nbsp;        var room = room(roomId);</b>
<b class="fc">&nbsp;        var chatMessage = ChatMessage.now(message, user.getId(), ChatMessageType.TEXT);</b>
<b class="fc">&nbsp;        return sendMessageToSuscribers(requestId, room, chatMessage);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public ChatMessagePayload sendImage(
&nbsp;            @Image
&nbsp;            @FileSize(value = 25, unit = FileSize.Unit.MB)
&nbsp;            MultipartFile file,
&nbsp;
&nbsp;            String roomId,
&nbsp;            String requestId,
&nbsp;            Jwt jwt
&nbsp;    ) throws IOException {
<b class="fc">&nbsp;        return sendFile(file, roomId, requestId, jwt, ChatMessageType.IMAGE, &quot;images&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public ChatMessagePayload sendVoice(
&nbsp;            @ContentType(&quot;audio/*&quot;)
&nbsp;            @FileSize(value = 25, unit = FileSize.Unit.MB)
&nbsp;            MultipartFile file,
&nbsp;
&nbsp;            String roomId,
&nbsp;
&nbsp;            String requestId,
&nbsp;
&nbsp;            Jwt jwt
&nbsp;
&nbsp;    ) throws IOException {
<b class="nc">&nbsp;        return sendFile(file, roomId, requestId, jwt, ChatMessageType.VOICE, &quot;voices&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    private ChatMessagePayload sendFile(
&nbsp;            MultipartFile file,
&nbsp;            String roomId,
&nbsp;            String requestId,
&nbsp;            Jwt jwt,
&nbsp;            ChatMessageType type,
&nbsp;            String dir
&nbsp;    ) throws IOException {
&nbsp;
<b class="fc">&nbsp;        var user = userService.getUser(jwt);</b>
<b class="fc">&nbsp;        var room = room(roomId);</b>
&nbsp;
<b class="fc">&nbsp;        var filePath = storage.store(</b>
<b class="fc">&nbsp;                file.getInputStream(),</b>
<b class="fc">&nbsp;                FileUtils.factoryUUIDFileName(file.getOriginalFilename()),</b>
<b class="fc">&nbsp;                String.format(USERS_CHATS_PATH, user.getId(), room.getId(), dir)</b>
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        var chatMessage = ChatMessage.now(filePath, user.getId(), type);</b>
<b class="fc">&nbsp;        return sendMessageToSuscribers(requestId, room, chatMessage);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Stored resource(String id) throws IOException {
<b class="nc">&nbsp;        return storage.download(id).orElseThrow(ProblemDetails::notFound);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ChatMessagePayload sendMessageToSuscribers(String requestId, ChatRoom room, ChatMessage chatMessage) {
<b class="fc">&nbsp;        var roomId = room.getId();</b>
<b class="fc">&nbsp;        addMessage(room, chatMessage);</b>
&nbsp;
<b class="fc">&nbsp;        var chatMessageSent = ChatMessagePayload.builder()</b>
<b class="fc">&nbsp;                .requestId(requestId)</b>
<b class="fc">&nbsp;                .roomId(roomId)</b>
<b class="fc">&nbsp;                .message(chatMessage)</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;
<b class="fc">&nbsp;        for (var participant : room.getParticipants()) {</b>
<b class="fc">&nbsp;            runAsync(() -&gt; {</b>
<b class="fc">&nbsp;                messaging.convertAndSend(&quot;/topic/chat.inbox.&quot; + participant, chatMessageSent);</b>
<b class="fc">&nbsp;                if (participant.equals(chatMessage.getSentBy())) return;</b>
<b class="fc">&nbsp;                notificationService.send(participant,</b>
&nbsp;                        &quot;Tienes un nuevo mensaje en tu calendario menstrual&quot;,
&nbsp;                        &quot;Ingresa a la aplicaci√≥n para revisarla.&quot;
&nbsp;                );
<b class="fc">&nbsp;            }).exceptionally(logExpecionally(&quot;Error enviando mensaje a la bandeja de entrada&quot;));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return chatMessageSent;</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public void read(String roomId, List&lt;String&gt; messagesIds, Jwt jwt) {
<b class="fc">&nbsp;        log.info(&quot;Marking messages as read: roomId={}, messagesIds={}&quot;, roomId, messagesIds);</b>
&nbsp;
<b class="fc">&nbsp;        var user = userService.getUser(jwt);</b>
<b class="fc">&nbsp;        var room = room(roomId);</b>
<b class="fc">&nbsp;        var userId = user.getId();</b>
&nbsp;
<b class="pc">&nbsp;        if (!room.getParticipants().contains(userId)) {</b>
<b class="nc">&nbsp;            throw ProblemDetails.forbidden(&quot;No tienes permiso para leer mensajes en esta sala de chat&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        var readBy = ChatMessage.ReadBy.now(userId);</b>
<b class="fc">&nbsp;        var query = new Query()</b>
<b class="fc">&nbsp;                .addCriteria(chunksOf(roomId).and(&quot;messages.id&quot;).in(messagesIds));</b>
&nbsp;
<b class="fc">&nbsp;        var update = new Update()</b>
<b class="fc">&nbsp;                .addToSet(&quot;messages.$[message].readBy&quot;, readBy)</b>
<b class="fc">&nbsp;                .filterArray(Criteria</b>
<b class="fc">&nbsp;                        .where(&quot;message._id&quot;).in(messagesIds)</b>
<b class="fc">&nbsp;                        .and(&quot;message.sentBy&quot;).ne(userId)</b>
<b class="fc">&nbsp;                        .and(&quot;message.readBy.participantId&quot;).ne(userId)</b>
&nbsp;                );
&nbsp;
<b class="fc">&nbsp;        var result = mongoTemplate.updateMulti(query, update, ChatChunk.class);</b>
&nbsp;
<b class="pc">&nbsp;        if (result.getModifiedCount() == 0) {</b>
<b class="nc">&nbsp;            log.warn(&quot;No se marcaron mensajes como le√≠dos&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        var readMessages = ReadMessages.builder()</b>
<b class="fc">&nbsp;                .roomId(roomId)</b>
<b class="fc">&nbsp;                .readBy(readBy)</b>
<b class="fc">&nbsp;                .messageIds(messagesIds)</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;
<b class="fc">&nbsp;        for (var participant : room.getParticipants()) {</b>
<b class="fc">&nbsp;            runAsync(() -&gt; messaging.convertAndSend(&quot;/topic/chat.inbox.&quot; + participant + &quot;.read&quot;, readMessages)).exceptionally(logExpecionally(&quot;Error enviando mensajes le√≠dos a la bandeja de entrada&quot;));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public ChatRoom room(String chatRoomId) {
<b class="fc">&nbsp;        return roomRepository.findById(chatRoomId).orElseThrow(() -&gt; ProblemDetails.notFound(&quot;No se encontr√≥ la sala de chat&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public List&lt;ChatRoom&gt; rooms(Jwt jwt) {
<b class="fc">&nbsp;        var user = userService.getUser(jwt);</b>
<b class="pc">&nbsp;        assert user.getId() != null;</b>
&nbsp;
<b class="fc">&nbsp;        return roomRepository.findByParticipant(user.getId())</b>
<b class="fc">&nbsp;                .stream()</b>
<b class="fc">&nbsp;                .filter(room -&gt; existsChunk(room.getId()))</b>
<b class="fc">&nbsp;                .toList();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public List&lt;ChatMessage&gt; messages(String roomId, long chunk) {
<b class="fc">&nbsp;        var query = new Query()</b>
<b class="fc">&nbsp;                .addCriteria(chunksOf(roomId).and(CHAT_CHUNK_NUMBER_KEY).is(chunk));</b>
&nbsp;
<b class="fc">&nbsp;        var chatChunk = mongoTemplate.findOne(query, ChatChunk.class);</b>
<b class="pc">&nbsp;        return chatChunk == null ? List.of() : chatChunk.getMessages();</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public ChatMessage lastMessage(String roomId) {
<b class="fc">&nbsp;        var aggregate = Aggregation.newAggregation(</b>
<b class="fc">&nbsp;                Aggregation.match(chunksOf(roomId)),</b>
<b class="fc">&nbsp;                Aggregation.sort(Sort.Direction.DESC, CHAT_CHUNK_NUMBER_KEY),</b>
<b class="fc">&nbsp;                Aggregation.limit(1),</b>
<b class="fc">&nbsp;                Aggregation.project()</b>
<b class="fc">&nbsp;                        .and(ArrayOperators.Last.lastOf(MESSAGES)).as(&quot;lastMessage&quot;)</b>
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        var result = mongoTemplate.aggregate(aggregate, ChatChunk.class, Document.class).getUniqueMappedResult();</b>
&nbsp;
<b class="pc">&nbsp;        if (result == null) return null;</b>
&nbsp;
<b class="fc">&nbsp;        var lastMessage = result.get(&quot;lastMessage&quot;, Document.class);</b>
<b class="fc">&nbsp;        return mongoTemplate.getConverter().read(ChatMessage.class, lastMessage);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     *     private ChatMessage message(String roomId, String messageId) {
&nbsp;     *         log.info(&quot;Searching for message: roomId={}, messageId={}&quot;, roomId, messageId);
&nbsp;     *         var aggregate = Aggregation.newAggregation(
&nbsp;     *                 Aggregation.match(chunksOf(roomId)),
&nbsp;     *                 Aggregation.unwind(MESSAGES),
&nbsp;     *                 Aggregation.match(Criteria.where(MESSAGES + &quot;._id&quot;).is(messageId)),
&nbsp;     *                 Aggregation.project()
&nbsp;     *                         .and(MESSAGES).as(&quot;message&quot;)
&nbsp;     *         );
&nbsp;     *         var result = mongoTemplate.aggregate(aggregate, ChatChunk.class, Document.class)
&nbsp;     *                 .getUniqueMappedResult();
&nbsp;     *         if (result == null) {
&nbsp;     *             log.warn(&quot;Message not found: roomId={}, messageId={}&quot;, roomId, messageId);
&nbsp;     *             throw ProblemDetails.notFound(&quot;No se encontr√≥ el mensaje&quot;);
&nbsp;     *         }
&nbsp;     *         var messageDoc = result.get(&quot;message&quot;, Document.class);
&nbsp;     *         return mongoTemplate.getConverter().read(ChatMessage.class, messageDoc);
&nbsp;     *     }
&nbsp;     * @param userId id del usuario con el que se quiere iniciar un chat
&nbsp;     * @param jwt token de autenticaci√≥n
&nbsp;     * @return ChatRoom
&nbsp;     */
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public ChatRoom room(Long userId, Jwt jwt) {
<b class="fc">&nbsp;        var user = userService.getUser(jwt);</b>
<b class="fc">&nbsp;        var recipient = userService.getUser(userId);</b>
<b class="fc">&nbsp;        return findOrCreatePrivateRoom(user.getId(), recipient.getId());</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreAuthorize(&quot;isAuthenticated()&quot;)
&nbsp;    public long chunkCount(String roomId) {
<b class="fc">&nbsp;        var query = new Query()</b>
<b class="fc">&nbsp;                .addCriteria(chunksOf(roomId));</b>
&nbsp;
<b class="fc">&nbsp;        return mongoTemplate.count(query, ChatChunk.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ChatRoom findOrCreatePrivateRoom(Long senderId, Long recipientId) {
<b class="fc">&nbsp;        return roomRepository</b>
<b class="fc">&nbsp;                .findByParticipantsAndType(List.of(senderId, recipientId), ChatRoomType.PRIVATE)</b>
<b class="fc">&nbsp;                .orElseGet(() -&gt; createPrivateRoom(senderId, recipientId));</b>
&nbsp;    }
&nbsp;
&nbsp;    private ChatRoom createPrivateRoom(Long senderId, Long recipientId) {
<b class="fc">&nbsp;        var newRoom = ChatRoom.builder()</b>
<b class="fc">&nbsp;                .type(ChatRoomType.PRIVATE)</b>
<b class="fc">&nbsp;                .participants(List.of(senderId, recipientId))</b>
<b class="fc">&nbsp;                .name(&quot;Private Chat between &quot; + senderId + &quot; and &quot; + recipientId)</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;
<b class="fc">&nbsp;        return roomRepository.save(newRoom);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean existsChunk(String roomId) {
<b class="fc">&nbsp;        var query = new Query()</b>
<b class="fc">&nbsp;                .addCriteria(chunksOf(roomId));</b>
&nbsp;
<b class="fc">&nbsp;        return mongoTemplate.exists(query, ChatChunk.class);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private long getChunkSize(String id) {
<b class="fc">&nbsp;        var aggregate = Aggregation.newAggregation(</b>
<b class="fc">&nbsp;                Aggregation.match(Criteria.where(&quot;_id&quot;).is(new ObjectId(id))),</b>
<b class="fc">&nbsp;                Aggregation.project()</b>
<b class="fc">&nbsp;                        .andExclude(&quot;_id&quot;)</b>
<b class="fc">&nbsp;                        .and(context -&gt; new Document(&quot;$bsonSize&quot;, Aggregation.ROOT)).as(&quot;size&quot;)</b>
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        var result = mongoTemplate.aggregate(aggregate, ChatChunk.class, Document.class).getUniqueMappedResult();</b>
&nbsp;
<b class="pc">&nbsp;        if (result == null) return 0;</b>
&nbsp;
<b class="fc">&nbsp;        var sizeValue = result.get(&quot;size&quot;, Number.class);</b>
<b class="pc">&nbsp;        return sizeValue != null ? sizeValue.longValue() : 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addMessage(ChatRoom chatRoom, ChatMessage message) {
&nbsp;
<b class="fc">&nbsp;        var query = new Query()</b>
<b class="fc">&nbsp;                .addCriteria(chunksOf(chatRoom.getId()))</b>
<b class="fc">&nbsp;                .with(Sort.by(Sort.Order.desc(CHAT_CHUNK_NUMBER_KEY)));</b>
&nbsp;
<b class="fc">&nbsp;        var projectedQuery = Query.of(query);</b>
<b class="fc">&nbsp;        projectedQuery.fields()</b>
<b class="fc">&nbsp;                .include(&quot;_id&quot;)</b>
<b class="fc">&nbsp;                .include(CHAT_CHUNK_NUMBER_KEY);</b>
&nbsp;
<b class="fc">&nbsp;        var latestChunk = mongoTemplate.findOne(projectedQuery, ChatChunk.class);</b>
&nbsp;
<b class="fc">&nbsp;        if (latestChunk == null) {</b>
<b class="fc">&nbsp;            mongoTemplate.save(ChatChunk.withFirstMessage(chatRoom, 1, message));</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        var aproxSize = getChunkSize(latestChunk.getId());</b>
&nbsp;
<b class="pc">&nbsp;        if (aproxSize &gt; ChatChunk.MAX_CHUNK_SIZE) {</b>
<b class="nc">&nbsp;            mongoTemplate.save(ChatChunk.withFirstMessage(chatRoom, latestChunk.getNumber() + 1, message));</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        var update = new Update();</b>
<b class="fc">&nbsp;        update.push(MESSAGES, message);</b>
&nbsp;
<b class="fc">&nbsp;        var result = mongoTemplate.updateFirst(query, update, ChatChunk.class);</b>
&nbsp;
<b class="pc">&nbsp;        if (result.getModifiedCount() == 0) {</b>
<b class="nc">&nbsp;            throw ProblemDetails.internalServerError(&quot;No se pudo agregar el mensaje al chat, resultado de la operaci√≥n: &quot; + result);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private static Criteria chunksOf(String roomId) {
<b class="fc">&nbsp;        return Criteria.where(CHAT_CHUNK_ROOM_KEY).is(new ObjectId(roomId));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Function&lt;Throwable, Void&gt; logExpecionally(String message) {
<b class="fc">&nbsp;        return ex -&gt; {</b>
<b class="nc">&nbsp;            log.error(message, ex);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-02-21 14:48</div>
</div>
</body>
</html>
